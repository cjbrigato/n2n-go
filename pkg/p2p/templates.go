package p2p

const peerHTML2 = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>D3 Graphviz Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh; /* Use full viewport height */
            font-family: sans-serif;
            background-color: #f4f4f4;
        }

        .grid-container {
            display: grid;
            /* Use fractional units for better flexibility */
            grid-template-columns: 1fr 3fr; /* Approx 25%% / 75%% */
            /* grid-template-columns: 25%% 75%%; /* Alternative if fixed %% is desired */
            height: 100%%; /* Fill parent (body) height */
            gap: 10px; /* Add some space between grid items */
            padding: 10px;
            box-sizing: border-box; /* Include padding in height/width */
        }

        /* Style for the left column container */
        .left-column {
            display: flex;
            flex-direction: column; /* Stack legend and offlines */
            gap: 10px; /* Space between legend and offlines */
            height: 100%%; /* Fill grid cell height */
        }

        .graph-area {
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            overflow: hidden; /* Important for SVG containment */
            /* Let flexbox handle height distribution or set fixed heights */
            position: relative; /* Needed for potential absolute positioned elements like spinners */
            display: flex; /* Center potential spinner/message */
            justify-content: center; /* Center potential spinner/message */
            align-items: center; /* Center potential spinner/message */
            /*min-height: 100px;*/ /* Ensure a minimum size */
        }

        /* Specific heights if needed, otherwise flex handles it */
        #legend {
             flex: 0 0 auto; /* Don't grow or shrink, base size on content (or set height) */
             /* height: 200px; /* Example fixed height */
        }
         #offlines {
             flex: 0 0 auto; /* Grow and shrink to fill remaining space */
         }
         #peers {
             height: 100%%; /* Fill grid cell height */
         }

        /* Style for the SVG generated by d3-graphviz */
        .graph-area svg {
            display: block; /* Remove extra space below SVG */
            width: 100%%;
            height: 100%%;
        }

        /* Basic loading/error message style */
        .graph-message {
            color: #888;
        }

    </style>
</head>
<body>

<!-- Grid structure -->
<div class="grid-container">
    <!-- Left column: Legend and Offline Peers -->
    <div class="left-column">
        <div id="legend" class="graph-area">
             <span class="graph-message">Loading Legend...</span>
        </div>
        <div id="offlines" class="graph-area">
            <span class="graph-message">Loading Offline Peers...</span>
        </div>
    </div>
    <!-- Right column: Online Peers -->
    <div id="peers" class="graph-area">
        <span class="graph-message">Loading Online Peers...</span>
    </div>
</div>

<!-- Load dependencies -->
<script src="//d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/@hpcc-js/wasm@2.20.0/dist/graphviz.umd.js"></script>
<script src="https://unpkg.com/d3-graphviz@5.6.0/build/d3-graphviz.js"></script>

<script>
    // Wrap in an IIFE or DOMContentLoaded to avoid polluting global scope
    document.addEventListener('DOMContentLoaded', () => {
        "use strict";

        // --- Configuration ---
        const STATIC_DOT_LEGEND = %s; // Server replaces this with the actual DOT string
        const PEERS_DOT_URL = "/peers.dot";
        const OFFLINES_DOT_URL = "/offlines.dot";
        const IMAGE_PATH = "/static/cloud.png";
        const IMAGE_WIDTH = "32px";
        const IMAGE_HEIGHT = "32px";
        const UPDATE_INTERVAL_MS = 2000; // Update every 2 seconds
        const TRANSITION_DELAY_MS = 50;
        const TRANSITION_DURATION_MS = 600; // Slightly faster transition

        // --- DOM Elements ---
        const legendContainer = d3.select("#legend");
        const offlinesContainer = d3.select("#offlines");
        const peersContainer = d3.select("#peers");
        // --- State Variables ---
        let isUpdating = false; // Flag to prevent concurrent updates
        let lastPeersDot = null; // Cache for the last rendered peers DOT string
        let lastOfflinesDot = null; // Cache for the last rendered offlines DOT string

        // --- Helper Functions ---

        /**
         * Creates and configures a d3-graphviz instance.
         * @param {d3.Selection} container - The D3 selection of the container div.
         * @param {string} [imagePath] - Optional path to an image to add.
         * @param {string} [imageWidth] - Optional image width.
         * @param {string} [imageHeight] - Optional image height.
         * @returns {d3.graphviz} - The configured graphviz instance.
         */
        function createGraphvizInstance(container, imagePath, imageWidth, imageHeight) {
            const graphvizInstance = container.graphviz({
                    useWorker: true, // Use web worker for performance
                    zoom: false      // Disable zooming
                })
                .transition(() => d3.transition("main")
                    .ease(d3.easeLinear)
                    .delay(TRANSITION_DELAY_MS)
                    .duration(TRANSITION_DURATION_MS)
                )
                .fit(true); // Fit graph to container

            // Add image only once during initialization
            if (imagePath && imageWidth && imageHeight) {
                graphvizInstance.addImage(imagePath, imageWidth, imageHeight);
            }

             // Handle initialization errors (optional but good practice)
             graphvizInstance.on("initEnd", () => {
                console.log(` + "`Graphviz initialized for #${container.attr('id')}`" + `);
                // Clear initial message once ready (renderDot will overwrite anyway)
                container.select('.graph-message').remove();
             });

             // Add error event listener
             graphvizInstance.onerror( (err) => {
                 console.error(` + "`Graphviz error in #${container.attr('id')}:`" + `, err);
                 displayMessage(container, ` + "`Error rendering graph: ${err.message}`" + `, true);
             });

            return graphvizInstance;
        }

 /**
         * Renders a DOT string if it's different from the cached version.
         * @param {d3.graphviz} graphvizInstance - The graphviz instance.
         * @param {string} newDotString - The newly fetched DOT string.
         * @param {string | null} lastDotString - The cached DOT string.
         * @param {d3.Selection} container - The container selection (for messages).
         * @returns {boolean} - True if a render was initiated, false otherwise.
         */
        function renderGraphIfChanged(graphvizInstance, newDotString, lastDotString, container) {
            // Trim whitespace for more reliable comparison
            const trimmedNewDot = newDotString?.trim();
            const trimmedLastDot = lastDotString?.trim();

            if (trimmedNewDot === trimmedLastDot) {
                 // console.log(` + "`Skipping render for #${container.attr('id')}: Data unchanged.`" + `);
                return false; // Data hasn't changed, don't render
            }

            if (!trimmedNewDot) {
                displayMessage(container, "No data to display.", false);
                // container.select('svg').remove(); // Optional: clear svg explicitly
                return true; // Indicate change occurred (from potentially something to nothing)
            }

            container.select('.graph-message').remove(); // Clear any previous messages

            try {
                console.log(` + "`Rendering updated data for #${container.attr('id')}`" + `);
                graphvizInstance.renderDot(trimmedNewDot);
                return true; // Render initiated
            } catch (error) {
                console.error(` + "`Error during renderDot call in #${container.attr('id')}:`" + `, error);
                displayMessage(container, ` + "`Render error: ${error.message}`" + `, true);
                return false; // Render failed
            }
        }


        /**
         * Renders a DOT string using a graphviz instance.
         * @param {d3.graphviz} graphvizInstance - The graphviz instance.
         * @param {string} dotString - The DOT string to render.
         * @param {d3.Selection} container - The container selection (for messages).
         */
        function renderGraph(graphvizInstance, dotString, container) {
            if (!dotString || dotString.trim() === '') {
                displayMessage(container, "No data to display.", false);
                // Optionally clear the SVG if needed: container.select('svg').remove();
                return;
            }
             // Clear any previous messages
             container.select('.graph-message').remove();

            try {
                graphvizInstance.renderDot(dotString);
            } catch (error) {
                console.error(` + "`Error during renderDot call in #${container.attr('id')}:`" + `, error);
                displayMessage(container, ` + "`Render error: ${error.message}`" + `, true);
            }
        }

         /**
          * Fetches data from a URL.
          * @param {string} url - The URL to fetch from.
          * @returns {Promise<string>} - A promise resolving with the text content.
          */
         async function fetchData(url) {
             try {
                 const response = await fetch(url);
                 if (!response.ok) {
				 const errorText = await response.text().catch(() => ''); // Try to get error body
                     throw new Error(` + "`HTTP error! Status: ${response.status} ${response.statusText}. ${errorText}	`" + `);
                 }
                 return await response.text();
             } catch (error) {
                 console.error(` + "`Failed to fetch data from ${url}:`" + `, error);
                 // Propagate error to be handled by caller
                 throw error;
             }
         }

        /**
         * Displays a message inside a graph container.
         * @param {d3.Selection} container - The D3 selection of the container.
         * @param {string} message - The message text.
         * @param {boolean} isError - True if the message is an error.
         */
        function displayMessage(container, message, isError) {
            // Clear existing SVG and message
            container.select('svg').remove();
            container.select('.graph-message').remove();

            container.append('span')
                .attr('class', 'graph-message')
                .style('color', isError ? '#d9534f' : '#888') // Red for errors
                .text(message);
        }

        // --- Initialization ---
        const graphvizLeg = createGraphvizInstance(legendContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);
        const graphvizOff = createGraphvizInstance(offlinesContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);
        const graphvizPeers = createGraphvizInstance(peersContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);

        // Render static legend immediately
        // Ensure STATIC_DOT_LEGEND is a valid DOT string or handle emptiness
        if (STATIC_DOT_LEGEND && STATIC_DOT_LEGEND.trim() !== '') {
             // Wait a tiny bit for initEnd potentially (though renderDot waits too)
             // Or rely on initEnd event if precise timing is needed.
             // For simplicity, direct render often works.
             renderGraph(graphvizLeg, STATIC_DOT_LEGEND, legendContainer);
         } else if (!STATIC_DOT_LEGEND || STATIC_DOT_LEGEND.trim() === '') {
            displayMessage(legendContainer, "Legend data not available.", false);
         }


        // --- Data Update Logic ---
        async function updateDynamicGraphs() {
            // Prevent concurrent updates
            if (isUpdating) {
                console.log("Update skipped: Previous update still in progress.");
                return;
            }
            isUpdating = true;
            // console.log("Starting update cycle...");

            try {
                // --- Fetch Peers ---
                let peersDot;
                try {
                    peersDot = await fetchData(PEERS_DOT_URL);
                    // Render only if data changed and update cache
                    if (renderGraphIfChanged(graphvizPeers, peersDot, lastPeersDot, peersContainer)) {
                         lastPeersDot = peersDot; // Update cache only on successful render trigger
                     }
                } catch (error) {
                     // Don't update cache on fetch error
                     displayMessage(peersContainer, ` + "`Failed to load peers: ${error.message}`" + `, true);
                     // Optionally reset lastPeersDot = null; if desired
                }

                // --- Fetch Offlines ---
                let offlinesDot;
                 try {
                    offlinesDot = await fetchData(OFFLINES_DOT_URL);
                     // Render only if data changed and update cache
                    if (renderGraphIfChanged(graphvizOff, offlinesDot, lastOfflinesDot, offlinesContainer)) {
                         lastOfflinesDot = offlinesDot; // Update cache only on successful render trigger
                     }
                 } catch (error) {
                     // Don't update cache on fetch error
                     displayMessage(offlinesContainer, ` + "`Failed to load offlines: ${error.message}`" + `, true);
                     // Optionally reset lastOfflinesDot = null; if desired
                 }

            } finally {
                // Ensure the lock is always released, even if errors occur
                isUpdating = false;
                 // console.log("Update cycle finished.");
            }
        }

        // --- Start ---
        // Perform initial fetch immediately
        updateDynamicGraphs();

        // Set up polling interval
        setInterval(updateDynamicGraphs, UPDATE_INTERVAL_MS);

    }); // End DOMContentLoaded
</script>

</body>
</html>
`

const offlinegraph = `
digraph G {
label=<<br/><font point-size="22">Offline Peers<br align="center"/></font>>
    rankdir=LR
    graph [fontname = "courier new" inputscale=0];
    labelloc="t"
    fontsize=16
    center=true
    node [fontname = "courier new" fontsize=11 shape=plain];
    edge [fontname = "courier new" len=4.5]
   bgcolor=transparent;
 fontsize=9
 fontname = "courier new"
 
 rank = same {
 %s
 }
}
`

const legend = `
digraph G {
    rankdir=LR
	label=<<font point-size="22">Legend<br align="center"/></font>>
	labelloc="t"
    fontsize=16
    center=true
    node [fontname = "courier new"];
    edge [fontsize=11 fontname="courier new"];
 

    fontsize=11
    fontname = "courier new"
    node [shape=plain];
    A -> B [label="Supernode I/O (no P2P)" style="dashed"  arrowhead=none, color=grey len=3.0]
    C -> D [label="Half Direct Connection" color=orange,style=bold len=3.0]
    E -> F [label="Full Duplex P2P" dir=both,style=bold, color=green]

  A [label=" "]
  B [label=" "]
  C [label=" "]
  D [label=" "]
  E [label=" "]
  F [label=" "]
}
`

const header = `
digraph G {
    graph [fontname = "courier new" inputscale=0];
    label=<<font point-size="22"><b>%s</b>'s Network<br align="center"/></font>>
    labelloc="t"
    fontsize=28
    center=true
    node [fontname = "courier new" fontsize=11 shape=underline];
    edge [fontname = "courier new" len=4.5]

   bgcolor=transparent;
   splines=true
   layout=neato
  normalize=-90
 `
