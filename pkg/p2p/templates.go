package p2p

const peerHTML2 = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>D3 Graphviz Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh; /* Use full viewport height */
            font-family: sans-serif;
            background-color: #f4f4f4;
        }

        .grid-container {
            display: grid;
            /* Use fractional units for better flexibility */
            grid-template-columns: 1fr 3fr; /* Approx 25%% / 75%% */
            /* grid-template-columns: 25%% 75%%; /* Alternative if fixed %% is desired */
            height: 100%%; /* Fill parent (body) height */
            gap: 10px; /* Add some space between grid items */
            padding: 10px;
            box-sizing: border-box; /* Include padding in height/width */
        }

        /* Style for the left column container */
        .left-column {
            display: flex;
            flex-direction: column; /* Stack legend and offlines */
            gap: 10px; /* Space between legend and offlines */
            height: 100%%; /* Fill grid cell height */
        }

        .graph-area {
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            overflow: hidden; /* Important for SVG containment */
            /* Let flexbox handle height distribution or set fixed heights */
            position: relative; /* Needed for potential absolute positioned elements like spinners */
            display: flex; /* Center potential spinner/message */
            justify-content: center; /* Center potential spinner/message */
            align-items: center; /* Center potential spinner/message */
            /*min-height: 100px;*/ /* Ensure a minimum size */
        }

        /* Specific heights if needed, otherwise flex handles it */
        #legend {
             flex: 0 0 auto; /* Don't grow or shrink, base size on content (or set height) */
             /* height: 200px; /* Example fixed height */
        }
         #offlines {
             flex: 0 0 auto; /* Grow and shrink to fill remaining space */
         }
         #peers {
             height: 100%%; /* Fill grid cell height */
         }

        /* Style for the SVG generated by d3-graphviz */
        .graph-area svg {
            display: block; /* Remove extra space below SVG */
            width: 100%%;
            height: 100%%;
        }

        /* Basic loading/error message style */
        .graph-message {
            color: #888;
        }

    </style>
</head>
<body>

<!-- Grid structure -->
<div class="grid-container">
    <!-- Left column: Legend and Offline Peers -->
    <div class="left-column">
        <div id="legend" class="graph-area">
             <span class="graph-message">Loading Legend...</span>
        </div>
        <div id="offlines" class="graph-area">
            <span class="graph-message">Loading Offline Peers...</span>
        </div>
    </div>
    <!-- Right column: Online Peers -->
    <div id="peers" class="graph-area">
        <span class="graph-message">Loading Online Peers...</span>
    </div>
</div>

<!-- Load dependencies -->
<script src="//d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/@hpcc-js/wasm@2.20.0/dist/graphviz.umd.js"></script>
<script src="https://unpkg.com/d3-graphviz@5.6.0/build/d3-graphviz.js"></script>

<script>
    // Wrap in an IIFE or DOMContentLoaded to avoid polluting global scope
    document.addEventListener('DOMContentLoaded', () => {
        "use strict";

        // --- Configuration ---
        const STATIC_DOT_LEGEND = %s; // Server replaces this with the actual DOT string
        const PEERS_DOT_URL = "/peers.dot";
        const OFFLINES_DOT_URL = "/offlines.dot";
        const IMAGE_PATH = "/static/cloud.png";
        const IMAGE_WIDTH = "32px";
        const IMAGE_HEIGHT = "32px";
        const UPDATE_INTERVAL_MS = 2000; // Update every 2 seconds
        const TRANSITION_DELAY_MS = 50;
        const TRANSITION_DURATION_MS = 600; // Slightly faster transition

        // --- DOM Elements ---
        const legendContainer = d3.select("#legend");
        const offlinesContainer = d3.select("#offlines");
        const peersContainer = d3.select("#peers");

        // --- Helper Functions ---

        /**
         * Creates and configures a d3-graphviz instance.
         * @param {d3.Selection} container - The D3 selection of the container div.
         * @param {string} [imagePath] - Optional path to an image to add.
         * @param {string} [imageWidth] - Optional image width.
         * @param {string} [imageHeight] - Optional image height.
         * @returns {d3.graphviz} - The configured graphviz instance.
         */
        function createGraphvizInstance(container, imagePath, imageWidth, imageHeight) {
            const graphvizInstance = container.graphviz({
                    useWorker: true, // Use web worker for performance
                    zoom: false      // Disable zooming
                })
                .transition(() => d3.transition("main")
                    .ease(d3.easeLinear)
                    .delay(TRANSITION_DELAY_MS)
                    .duration(TRANSITION_DURATION_MS)
                )
                .fit(true); // Fit graph to container

            // Add image only once during initialization
            if (imagePath && imageWidth && imageHeight) {
                graphvizInstance.addImage(imagePath, imageWidth, imageHeight);
            }

             // Handle initialization errors (optional but good practice)
             graphvizInstance.on("initEnd", () => {
                console.log(` + "`Graphviz initialized for #${container.attr('id')}`" + `);
                // Clear initial message once ready (renderDot will overwrite anyway)
                container.select('.graph-message').remove();
             });

             // Add error event listener
             graphvizInstance.onerror( (err) => {
                 console.error(` + "`Graphviz error in #${container.attr('id')}:`" + `, err);
                 displayMessage(container, ` + "`Error rendering graph: ${err.message}`" + `, true);
             });

            return graphvizInstance;
        }

        /**
         * Renders a DOT string using a graphviz instance.
         * @param {d3.graphviz} graphvizInstance - The graphviz instance.
         * @param {string} dotString - The DOT string to render.
         * @param {d3.Selection} container - The container selection (for messages).
         */
        function renderGraph(graphvizInstance, dotString, container) {
            if (!dotString || dotString.trim() === '') {
                displayMessage(container, "No data to display.", false);
                // Optionally clear the SVG if needed: container.select('svg').remove();
                return;
            }
             // Clear any previous messages
             container.select('.graph-message').remove();

            try {
                graphvizInstance.renderDot(dotString);
            } catch (error) {
                console.error(` + "`Error during renderDot call in #${container.attr('id')}:`" + `, error);
                displayMessage(container, ` + "`Render error: ${error.message}`" + `, true);
            }
        }

         /**
          * Fetches data from a URL.
          * @param {string} url - The URL to fetch from.
          * @returns {Promise<string>} - A promise resolving with the text content.
          */
         async function fetchData(url) {
             try {
                 const response = await fetch(url);
                 if (!response.ok) {
                     throw new Error(` + "`HTTP error! Status: ${response.status} ${response.statusText}`" + `);
                 }
                 return await response.text();
             } catch (error) {
                 console.error(` + "`Failed to fetch data from ${url}:`" + `, error);
                 // Propagate error to be handled by caller
                 throw error;
             }
         }

        /**
         * Displays a message inside a graph container.
         * @param {d3.Selection} container - The D3 selection of the container.
         * @param {string} message - The message text.
         * @param {boolean} isError - True if the message is an error.
         */
        function displayMessage(container, message, isError) {
            // Clear existing SVG and message
            container.select('svg').remove();
            container.select('.graph-message').remove();

            container.append('span')
                .attr('class', 'graph-message')
                .style('color', isError ? '#d9534f' : '#888') // Red for errors
                .text(message);
        }

        // --- Initialization ---
        const graphvizLeg = createGraphvizInstance(legendContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);
        const graphvizOff = createGraphvizInstance(offlinesContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);
        const graphvizPeers = createGraphvizInstance(peersContainer, IMAGE_PATH, IMAGE_WIDTH, IMAGE_HEIGHT);

        // Render static legend immediately
        // Ensure STATIC_DOT_LEGEND is a valid DOT string or handle emptiness
        if (STATIC_DOT_LEGEND && STATIC_DOT_LEGEND.trim() !== '') {
             // Wait a tiny bit for initEnd potentially (though renderDot waits too)
             // Or rely on initEnd event if precise timing is needed.
             // For simplicity, direct render often works.
             renderGraph(graphvizLeg, STATIC_DOT_LEGEND, legendContainer);
         } else if (!STATIC_DOT_LEGEND || STATIC_DOT_LEGEND.trim() === '') {
            displayMessage(legendContainer, "Legend data not available.", false);
         }


        // --- Data Update Logic ---
        async function updateDynamicGraphs() {
            // Fetch peers data
            try {
                const peersDot = await fetchData(PEERS_DOT_URL);
                renderGraph(graphvizPeers, peersDot, peersContainer);
            } catch (error) {
                 displayMessage(peersContainer, ` + "`Failed to load peers: ${error.message}`" + `, true);
            }

            // Fetch offlines data
            try {
                const offlinesDot = await fetchData(OFFLINES_DOT_URL);
                renderGraph(graphvizOff, offlinesDot, offlinesContainer);
                // Note: We are NOT re-rendering the static legend here anymore.
            } catch (error) {
                 displayMessage(offlinesContainer, ` + "`Failed to load offlines: ${error.message}`" + `, true);
            }
        }

        // --- Start ---
        // Perform initial fetch immediately
        updateDynamicGraphs();

        // Set up polling interval
        setInterval(updateDynamicGraphs, UPDATE_INTERVAL_MS);

    }); // End DOMContentLoaded
</script>

</body>
</html>
`
